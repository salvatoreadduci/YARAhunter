import requests
import os
import glob
import json
import concurrent.futures
from database import is_malware_downloaded, insert_malware
from utils import unzip_file, get_number_of_workers, print_message, MessageLevel, console
from config import app_options


def get_malware_hashes(signature: str) -> dict:
    headers = {"Auth-Key": app_options.abuse_api_key}
    
    data = {
    "query": "get_siginfo",
    "signature": signature,
    "limit": app_options.number_of_malwares
    }

    try:
        response = requests.post(app_options.malware_bazaar_url, headers=headers, data=data, timeout=app_options.timeout)
        response.raise_for_status()
        hashes = response.json()
        
        if "data" not in hashes:
            return {}
        
        mapped_data = {item['sha256_hash']: item.get('signature', "Unknown") for item in hashes.get('data', [])}
        print_message(f"{signature} hashes obtained.", MessageLevel.INFO)
        return mapped_data

    except requests.exceptions.RequestException as req_err:
        print_message(req_err, MessageLevel.ERROR)
    except Exception as e:
        print_message(e, MessageLevel.ERROR)
    
    return {}


def fetch_malware_file(hash_value: str):
    headers = {"Auth-Key": app_options.abuse_api_key}
    data = {"query": "get_file", "sha256_hash": hash_value}
    
    try:
        response = requests.post(app_options.malware_bazaar_url, headers=headers, data=data, stream=True, timeout=app_options.timeout)
        response.raise_for_status()
        return response
    except Exception as e:
        print_message(f"Fetching {hash_value} - {e}", MessageLevel.ERROR)
    return None


def save_malware_file(response, file_path: str):
    with open(file_path, 'wb') as f:
        for chunk in response.iter_content(chunk_size=1024):
            if chunk:
                f.write(chunk)


def download_malware(hash_value: str, family_name: str) -> bool:
    family_dir = os.path.join(app_options.download_dir, family_name)
    os.makedirs(family_dir, exist_ok=True)
    
    if is_malware_downloaded(hash_value):
        print_message(f"{hash_value} already downloaded.", MessageLevel.WARNING)
        return False
    
    response = fetch_malware_file(hash_value)
    if response:
        content_type = response.headers.get("Content-Type", "")
        if "application/json" in content_type:
            try:
                json_data = response.json()
                if "ratelimited" in json.dumps(json_data).lower():
                    return False
            except json.JSONDecodeError:
                pass

        filename = os.path.join(family_dir, f"{hash_value}.zip")
        save_malware_file(response, filename)
        unzip_file(filename, family_dir, app_options.zip_password)
        print_message(f"{hash_value} downloaded.", MessageLevel.INFO)
        existing_file = glob.glob(os.path.join(family_dir, f"{hash_value}.*"))
        if existing_file:
            insert_malware(existing_file[0], hash_value, family_name)
        return True
    return False


def malwares() -> None:
    all_hashes = {}
    with console.status("Obtaining hashes..."):
        try:
            with concurrent.futures.ThreadPoolExecutor(max_workers=get_number_of_workers()) as executor:
                future_to_signature = {executor.submit(get_malware_hashes, sig): sig for sig in app_options.malware_signatures}

                for future in concurrent.futures.as_completed(future_to_signature):
                    try:
                        malware_hashes = future.result()
                        all_hashes.update(malware_hashes)
                    except Exception as e:
                        print_message(f"Processing signature {future_to_signature[future]} - {e}", MessageLevel.ERROR)

        except Exception as e:
            print_message(f"Signature list empty. Update signature list.", MessageLevel.WARNING)
            return False
    
    os.makedirs(app_options.download_dir,exist_ok=True)
    
    if all_hashes:
        with concurrent.futures.ThreadPoolExecutor(max_workers=get_number_of_workers()) as executor:
            results = list(executor.map(download_malware, all_hashes.keys(), all_hashes.values()))
        
        new_malwares = sum(results)
        existing_malwares = len(all_hashes) - new_malwares
        
        print_message(f"Malwares collected: {new_malwares} new, {existing_malwares} skipped.", MessageLevel.SUCCESS)
        return True
    else:
        print_message("No malware found.", MessageLevel.ERROR)
        return False
